package dev.mccue.jdbc;

import org.intellij.lang.annotations.Language;
import org.intellij.lang.annotations.MagicConstant;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * An implementation of {@link StringTemplate.Processor} which
 * makes {@link PreparedStatement} objects given a {@link Connection}.
 */
public final class StatementPreparer
        implements StringTemplate.Processor<PreparedStatement, SQLException> {
    private interface PreparedStatementMaker {
        PreparedStatement make(String sql) throws SQLException;
    }

    private final PreparedStatementMaker maker;

    private StatementPreparer(PreparedStatementMaker maker) {
        this.maker = maker;
    }

    /**
     * Returns an instance of {@link StatementPreparer}.
     *
     * @param connection The connection to make a {@link PreparedStatement} for.
     * @return an instance of {@link StatementPreparer}.
     */
    @Language("SQL")
    public static StringTemplate.Processor<PreparedStatement, SQLException> of(Connection connection) {
        return new StatementPreparer(connection::prepareStatement);
    }

    /**
     * Returns an instance of {@link StatementPreparer}.
     *
     * @param connection The connection to make a {@link PreparedStatement} for.
     * @param columnNames An array of column names indicating the columns that should be returned from the inserted row or rows.
     * @return an instance of {@link StatementPreparer}.
     */
    @Language("SQL")
    public static StringTemplate.Processor<PreparedStatement, SQLException> of(Connection connection, String[] columnNames) {
        return new StatementPreparer(sql -> connection.prepareStatement(sql, columnNames));
    }

    /**
     * Returns an instance of {@link StatementPreparer}.
     *
     * @param connection The connection to make a {@link PreparedStatement} for.
     * @param columnIndexes An array of column indexes indicating the columns that should be returned from the inserted row or rows.
     * @return an instance of {@link StatementPreparer}.
     */
    @Language("SQL")
    public static StringTemplate.Processor<PreparedStatement, SQLException> of(Connection connection, int[] columnIndexes) {
        return new StatementPreparer(sql -> connection.prepareStatement(sql, columnIndexes));
    }

    /**
     * Returns an instance of {@link StatementPreparer}.
     *
     * @param connection The connection to make a {@link PreparedStatement} for.
     * @param autoGeneratedKeys a flag indicating whether auto-generated keys
     *        should be returned; one of
     *        {@code Statement.RETURN_GENERATED_KEYS} or
     *        {@code Statement.NO_GENERATED_KEYS}
     * @return an instance of {@link StatementPreparer}.
     */
    @Language("SQL")
    public static StringTemplate.Processor<PreparedStatement, SQLException> of(
            Connection connection,
            @MagicConstant(intValues = {
                    Statement.RETURN_GENERATED_KEYS,
                    Statement.NO_GENERATED_KEYS
            }) int autoGeneratedKeys) {
        return new StatementPreparer(sql -> connection.prepareStatement(sql, autoGeneratedKeys));
    }

    /**
     * Returns an instance of {@link StatementPreparer}.
     *
     * @param connection The connection to make a {@link PreparedStatement} for.
     * @param resultSetType a result set type; one of
     *         {@code ResultSet.TYPE_FORWARD_ONLY},
     *         {@code ResultSet.TYPE_SCROLL_INSENSITIVE}, or
     *         {@code ResultSet.TYPE_SCROLL_SENSITIVE}
     * @param resultSetConcurrency a concurrency type; one of
     *         {@code ResultSet.CONCUR_READ_ONLY} or
     *         {@code ResultSet.CONCUR_UPDATABLE}
     * @return an instance of {@link StatementPreparer}.
     */
    @Language("SQL")
    public static StringTemplate.Processor<PreparedStatement, SQLException> of(
            Connection connection,
            @MagicConstant(intValues = {
                    ResultSet.TYPE_FORWARD_ONLY,
                    ResultSet.TYPE_SCROLL_INSENSITIVE,
                    ResultSet.TYPE_SCROLL_SENSITIVE
            }) int resultSetType,
            @MagicConstant(intValues = {
                    ResultSet.CONCUR_READ_ONLY,
                    ResultSet.CONCUR_UPDATABLE
            }) int resultSetConcurrency
    ) {
        return new StatementPreparer(sql -> connection.prepareStatement(sql, resultSetType, resultSetConcurrency));
    }


    /**
     * Returns an instance of {@link StatementPreparer}.
     *
     * @param connection The connection to make a {@link PreparedStatement} for.
     * @param resultSetType one of the following {@code ResultSet}
     *        constants:
     *         {@code ResultSet.TYPE_FORWARD_ONLY},
     *         {@code ResultSet.TYPE_SCROLL_INSENSITIVE}, or
     *         {@code ResultSet.TYPE_SCROLL_SENSITIVE}
     * @param resultSetConcurrency one of the following {@code ResultSet}
     *        constants:
     *         {@code ResultSet.CONCUR_READ_ONLY} or
     *         {@code ResultSet.CONCUR_UPDATABLE}
     * @param resultSetHoldability one of the following {@code ResultSet}
     *        constants:
     *         {@code ResultSet.HOLD_CURSORS_OVER_COMMIT} or
     *         {@code ResultSet.CLOSE_CURSORS_AT_COMMIT}
     * @return an instance of {@link StatementPreparer}.
     */
    @Language("SQL")
    public static StringTemplate.Processor<PreparedStatement, SQLException> of(
            Connection connection,
            @MagicConstant(intValues = {
                    ResultSet.TYPE_FORWARD_ONLY,
                    ResultSet.TYPE_SCROLL_INSENSITIVE,
                    ResultSet.TYPE_SCROLL_SENSITIVE
            }) int resultSetType,
            @MagicConstant(intValues = {
                    ResultSet.CONCUR_READ_ONLY,
                    ResultSet.CONCUR_UPDATABLE
            }) int resultSetConcurrency,
            @MagicConstant(intValues = {
                    ResultSet.HOLD_CURSORS_OVER_COMMIT,
                    ResultSet.CLOSE_CURSORS_AT_COMMIT
            }) int resultSetHoldability) {
        return new StatementPreparer(sql -> connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
    }


    @Override
    public PreparedStatement process(StringTemplate stringTemplate) throws SQLException {
        var fragments = stringTemplate.fragments();
        var values = stringTemplate.values();

        int fragmentsSize = fragments.size();
        int valuesSize = values.size();

        if (fragmentsSize == 1) {
            return maker.make(fragments.getFirst());
        } else {
            var params = new ArrayList<SettableParameter>();
            var strings = new StringBuilder();

            for (int i = 0; i < valuesSize; ++i) {
                strings.append(fragments.get(i));
                var value = values.get(i);
                switch (value) {
                    case SettableParameter s -> {
                        params.add(s);
                        strings.append("?");
                    }
                    case List<?> list -> {
                        if (list.isEmpty()) {
                            throw new SQLException("Empty list given to StatementPreparer");
                        }
                        strings.append("(");
                        list.forEach(o -> {
                                    switch (o) {
                                        case SettableParameter s -> params.add(s);
                                        case null, default -> params.add(SettableParameter.ofObject(o));
                                    }
                                }
                        );
                        strings.append(
                                Stream.generate(() -> "?")
                                        .limit(list.size())
                                        .collect(Collectors.joining(","))
                        );
                        strings.append(")");
                    }
                    case null, default -> {
                        params.add(SettableParameter.ofObject(value));
                        strings.append("?");
                    }
                }
            }

            var preparedStatement = maker.make(strings.toString());

            for (int i = 0; i < params.size(); i++) {
                params.get(i).setParameter(preparedStatement, i + 1);
            }

            return preparedStatement;
        }
    }
}
